<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Vamba // Procedural World</title>
    <style>
        :root {
            --neon-pink: #ff4081;
            --neon-cyan: #00e5ff;
            --bg-dark: #0a0a0f;
            --bg-panel: rgba(15, 18, 32, 0.75);
            --border-color: rgba(0, 229, 255, 0.3);
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0b0;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-dark);
            font-family: 'Consolas', 'Menlo', monospace;
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        #vamba-panel {
            width: 400px;
            height: 100%;
            background-color: var(--bg-panel);
            backdrop-filter: blur(10px);
            border-right: 1px solid var(--border-color);
            z-index: 103;
            box-shadow: 5px 0 25px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            color: var(--text-primary);
            transition: transform 0.4s ease-in-out;
        }

        .vamba-header {
            padding: 20px;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        .vamba-header h1 {
            margin: 0;
            font-size: 2rem;
            color: var(--neon-cyan);
            font-weight: bold;
            text-shadow: 0 0 5px var(--neon-cyan), 0 0 10px var(--neon-cyan), 0 0 20px #fff;
        }
        
        nav.vamba-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        .tab-link {
            flex: 1;
            padding: 15px 10px;
            text-align: center;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            position: relative;
        }
        .tab-link:hover {
            color: var(--neon-pink);
            background: rgba(255, 64, 129, 0.1);
        }
        .tab-link.active {
            color: var(--text-primary);
            text-shadow: 0 0 3px var(--neon-pink);
        }
        .tab-link.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: var(--neon-pink);
            box-shadow: 0 0 5px var(--neon-pink);
        }

        .tab-content {
            display: none;
            overflow-y: auto;
            flex-grow: 1;
            padding: 20px;
            animation: fadeIn 0.5s ease;
        }
        .tab-content.active {
            display: block;
        }
        .tab-content::-webkit-scrollbar { width: 6px; }
        .tab-content::-webkit-scrollbar-track { background: transparent; }
        .tab-content::-webkit-scrollbar-thumb { background-color: var(--neon-pink); border-radius: 3px; }

        .content-section h2 {
            color: var(--neon-cyan);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-top: 0;
        }
        .content-section p, .content-section ul {
            line-height: 1.6;
            color: var(--text-secondary);
        }
        .content-section a {
            color: var(--neon-pink);
            text-decoration: none;
            transition: text-shadow 0.2s;
        }
        .content-section a:hover {
            text-decoration: underline;
            text-shadow: 0 0 5px var(--neon-pink);
        }

        .vamba-button {
            background: transparent;
            border: 1px solid var(--neon-pink);
            color: var(--neon-pink);
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px rgba(255, 64, 129, 0.5);
            margin-top: 10px;
        }
        .vamba-button:hover {
            background: var(--neon-pink);
            color: var(--bg-dark);
            box-shadow: 0 0 15px var(--neon-pink);
        }
        .vamba-button.icon-button {
            padding: 10px;
            width: 42px;
            height: 42px;
            font-size: 1.2rem;
            border-radius: 50%;
        }

        #scene-container {
            flex: 1;
            position: relative;
            transition: width 0.4s ease-in-out;
        }

        #glcanvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        #start-prompt {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 100;
            cursor: pointer;
            transition: opacity 0.5s;
        }
        #start-prompt.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #start-prompt h1 {
            font-size: 2.5rem;
            text-shadow: 0 0 12px var(--neon-cyan), 0 0 20px var(--neon-cyan);
        }
        #debug-info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 3px;
            z-index: 101;
            text-shadow: 1px 1px 2px black;
            transition: opacity 0.3s;
        }

        /* --- Sandbox Controls --- */
        .control-group { margin: 20px 0; }
        .control-group label { display: block; margin-bottom: 10px; color: var(--text-secondary); }
        input[type="range"] {
            width: 100%;
            cursor: pointer;
            -webkit-appearance: none;
            background: transparent;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            height: 4px; background: var(--border-color); border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 18px; width: 18px; border-radius: 50%; background: var(--neon-pink);
            border: 2px solid var(--bg-dark); margin-top: -7px;
            box-shadow: 0 0 5px var(--neon-pink);
        }
        .weather-buttons { display: flex; gap: 10px; }
        .weather-btn {
            flex: 1; border: 1px solid var(--border-color); background: transparent;
            color: var(--text-secondary); padding: 8px; cursor: pointer; transition: all 0.3s;
        }
        .weather-btn:hover { color: var(--neon-pink); border-color: var(--neon-pink); }
        .weather-btn.active { color: var(--bg-dark); background: var(--neon-cyan); border-color: var(--neon-cyan); box-shadow: 0 0 10px var(--neon-cyan); }
        .sandbox-actions { display: flex; gap: 10px; align-items: center; }

        /* --- Mobile Controls & UI --- */
        #mobile-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 102;
            display: none;
            transition: opacity 0.3s;
        }
        #joystick-container, #action-container { pointer-events: auto; }
        #joystick-container { position: absolute; bottom: 30px; left: 30px; width: 150px; height: 150px; }
        #joystick-base { position: relative; width: 100%; height: 100%; background: rgba(0, 229, 255, 0.2); border-radius: 50%; border: 2px solid rgba(0, 229, 255, 0.4); }
        #joystick-handle { position: absolute; top: 50%; left: 50%; width: 60px; height: 60px; background: rgba(0, 229, 255, 0.4); border-radius: 50%; transform: translate(-50%, -50%); transition: transform 0.05s linear; }
        #action-container { position: absolute; bottom: 30px; right: 30px; display: flex; flex-direction: column; align-items: center; gap: 15px; }
        .action-button { width: 60px; height: 60px; background: rgba(255, 64, 129, 0.2); border: 2px solid rgba(255, 64, 129, 0.4); border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 24px; color: #fff; user-select: none; -webkit-user-select: none; }
        .action-button:active { background: rgba(255, 64, 129, 0.5); }
        
        #mobile-menu-toggle {
            position: fixed;
            top: 15px;
            left: 15px;
            width: 45px;
            height: 45px;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            color: var(--neon-cyan);
            font-size: 1.5rem;
            font-weight: bold;
            z-index: 104;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        #mobile-menu-toggle:active { transform: scale(0.9); }
        
        body.photo-mode #debug-info,
        body.photo-mode #mobile-controls,
        body.photo-mode #mobile-menu-toggle {
            opacity: 0;
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            body { flex-direction: column; }
            #vamba-panel {
                position: fixed;
                width: 100%;
                height: 100%;
                top: 0; left: 0;
                transform: translateX(-100%);
                border-right: none;
            }
            #vamba-panel.mobile-visible {
                transform: translateX(0);
            }
            #scene-container { width: 100%; height: 100%; }
            #mobile-menu-toggle { display: flex; }
        }
    </style>
</head>
<body>
    <aside id="vamba-panel">
        <div class="vamba-header">
            <h1>Vamba</h1>
        </div>
        <nav class="vamba-tabs">
            <button class="tab-link active" data-tab="home">–ì–ª–∞–≤–Ω–∞—è</button>
            <button class="tab-link" data-tab="links">–°—Å—ã–ª–∫–∏</button>
            <button class="tab-link" data-tab="sandbox">–ü–µ—Å–æ—á–Ω–∏—Ü–∞</button>
        </nav>

        <div id="home" class="tab-content active">
            <div class="content-section">
                <h2>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å</h2>
                <p>–í—ã –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –≤ Vamba ‚Äî –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ, –æ–±—ä–µ–¥–∏–Ω—è—é—â–µ–º —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏ –∏ —ç—Å—Ç–µ—Ç–∏–∫—É –∫–∏–±–µ—Ä–ø–∞–Ω–∫–∞. –°–ø—Ä–∞–≤–∞ –≤—ã –≤–∏–¥–∏—Ç–µ –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º—ã–π 3D-–º–∏—Ä.</p>
                <p>–ò—Å—Å–ª–µ–¥—É–π—Ç–µ –µ–≥–æ —Å –ø–æ–º–æ—â—å—é –∫–ª–∞–≤–∏—à WASD –∏ –º—ã—à–∏. –ù–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–µ–Ω—Å–æ—Ä–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ.</p>
            </div>
             <div class="content-section">
                <h2>–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è</h2>
                <p>–≠—Ç–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏. –°–∏—Å—Ç–µ–º–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–¥—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç –∫–∞—á–µ—Å—Ç–≤–æ –≥—Ä–∞—Ñ–∏–∫–∏ –¥–ª—è –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è –ø–ª–∞–≤–Ω–æ–π —Ä–∞–±–æ—Ç—ã.</p>
            </div>
        </div>

        <div id="links" class="tab-content">
            <div class="content-section">
                <h2>–°–ª—É—á–∞–π–Ω—ã–µ –†–µ—Å—É—Ä—Å—ã</h2>
                <p>–ü–æ–¥–±–æ—Ä–∫–∞ –ø–æ–ª–µ–∑–Ω—ã—Ö —Å—Å—ã–ª–æ–∫ –Ω–∞ –æ–±—Ä–∞–∑–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ, –Ω–∞—É—á–Ω—ã–µ –∏ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ —Ä–µ—Å—É—Ä—Å—ã.</p>
                <ul id="useful-links-list"></ul>
                <button id="new-links-btn" class="vamba-button">–ù–æ–≤—ã–µ —Å—Å—ã–ª–∫–∏</button>
            </div>
        </div>

        <div id="sandbox" class="tab-content">
            <div class="content-section">
                <h2>3D –ü–µ—Å–æ—á–Ω–∏—Ü–∞</h2>
                <p>–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤—É–π—Ç–µ —Å 3D-–º–∏—Ä–æ–º. –ú–µ–Ω—è–π—Ç–µ –ø–æ–≥–æ–¥—É, –≤—Ä–µ–º—è —Å—É—Ç–æ–∫ –∏–ª–∏ —Å–æ–∑–¥–∞–π—Ç–µ –∞–±—Å–æ–ª—é—Ç–Ω–æ –Ω–æ–≤—ã–π –ª–∞–Ω–¥—à–∞—Ñ—Ç.</p>
                <div class="control-group">
                    <label for="time-slider">–í—Ä–µ–º—è —Å—É—Ç–æ–∫</label>
                    <input type="range" id="time-slider" min="0" max="1" step="0.005" value="0.25">
                </div>
                <div class="control-group">
                    <label>–ü–æ–≥–æ–¥–∞</label>
                    <div id="weather-controls" class="weather-buttons">
                        <button class="weather-btn active" data-weather="0">‚òÄÔ∏è –Ø—Å–Ω–æ</button>
                        <button class="weather-btn" data-weather="1">‚òÅÔ∏è –ü–∞—Å–º—É—Ä–Ω–æ</button>
                        <button class="weather-btn" data-weather="2">üåßÔ∏è –î–æ–∂–¥—å</button>
                    </div>
                </div>
                <div class="control-group">
                    <label for="volume-slider">–û–±—â–∞—è –≥—Ä–æ–º–∫–æ—Å—Ç—å</label>
                    <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.5">
                </div>
                <div class="sandbox-actions">
                    <button id="regenerate-world-btn" class="vamba-button">–ü–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å –ú–∏—Ä</button>
                    <button id="photo-mode-btn" class="vamba-button icon-button" title="–§–æ—Ç–æ-—Ä–µ–∂–∏–º">üì∑</button>
                </div>
            </div>
        </div>
    </aside>

    <main id="scene-container">
        <div id="start-prompt">
            <h1>Procedural World</h1>
            <p>Click or Tap to Explore</p>
        </div>
        <div id="debug-info"></div>
        <canvas id="glcanvas"></canvas>
        <div id="mobile-controls">
            <div id="joystick-container">
                <div id="joystick-base">
                    <div id="joystick-handle"></div>
                </div>
            </div>
            <div id="action-container">
                <div id="sprint-button" class="action-button">üöÄ</div>
                <div id="up-button" class="action-button">üîº</div>
                <div id="down-button" class="action-button">üîΩ</div>
            </div>
        </div>
        <button id="mobile-menu-toggle">V</button>
    </main>

    <!-- Vertex Shader: Pass-through for a full-screen quad -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <!-- Fragment Shader: The heart of the renderer -->
    <script id="fragment-shader" type="x-shader/x-fragment">
    precision highp float;

    // --- Uniforms ---
    uniform vec2 u_resolution;
    uniform float u_time;
    uniform vec3 u_camPos;
    uniform mat3 u_camMat;
    uniform vec3 u_sunDir;
    uniform float u_seed;
    uniform float u_weather; // 0: clear, 1: overcast, 2: rain

    // --- Compile-time Quality Settings ---
    #define QUALITY_POTATO 0
    #define QUALITY_LOW 1
    #define QUALITY_MEDIUM 2
    #define QUALITY_HIGH 3
    #define QUALITY_ULTRA 4

    #if !defined(QUALITY_LEVEL)
        #define QUALITY_LEVEL QUALITY_HIGH
    #endif

    // --- Quality-dependent Constants ---
    #if QUALITY_LEVEL == QUALITY_ULTRA
        const int MAX_STEPS = 120; const int AO_STEPS = 6; const int SHADOW_STEPS = 48; const int CLOUD_STEPS = 80;
    #elif QUALITY_LEVEL == QUALITY_HIGH
        const int MAX_STEPS = 100; const int AO_STEPS = 4; const int SHADOW_STEPS = 32; const int CLOUD_STEPS = 64;
    #elif QUALITY_LEVEL == QUALITY_MEDIUM
        const int MAX_STEPS = 70; const int AO_STEPS = 2; const int SHADOW_STEPS = 16; const int CLOUD_STEPS = 48;
    #elif QUALITY_LEVEL == QUALITY_LOW
        const int MAX_STEPS = 50;
    #else // POTATO
        const int MAX_STEPS = 35;
    #endif

    // --- World Constants ---
    const float MAX_DIST = 2000.0;
    const float SURF_DIST = 0.002;
    const float SEA_LEVEL = 0.8;
    const float SNOW_LINE = 250.0;

    // --- Material IDs ---
    const float MAT_TERRAIN = 1.0;
    const float MAT_WATER = 2.0;
    
    struct Material { vec3 albedo; float smoothness; float specularity; };

    // --- Noise Functions ---
    float rand(vec2 n) { return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }
    float noise(vec2 p) {
        vec2 ip = floor(p); vec2 u = fract(p); u = u*u*(3.0-2.0*u);
        return mix(mix(rand(ip), rand(ip + vec2(1,0)), u.x),
                   mix(rand(ip + vec2(0,1)), rand(ip + vec2(1,1)), u.x), u.y);
    }
    float noise(vec3 p) {
        vec3 ip = floor(p); vec3 u = fract(p); u = u*u*(3.0-2.0*u);
        float n = mix(mix(mix(rand(ip.xy), rand(ip.xy + vec2(1,0)), u.x),
                        mix(rand(ip.xy + vec2(0,1)), rand(ip.xy + vec2(1,1)), u.x), u.y),
                    mix(mix(rand(ip.xy + vec2(57,113)), rand(ip.xy + vec2(58,113)), u.x),
                        mix(rand(ip.xy + vec2(57,114)), rand(ip.xy + vec2(58,114)), u.x), u.y), u.z);
        return n;
    }
    mat2 rot(float a) { float s=sin(a),c=cos(a); return mat2(c,-s,s,c); }
    float fbm(vec2 p, int octaves) {
        float f = 0.0; float a = 0.5;
        for (int i=0; i<7; i++) {
            if (i >= octaves) break;
            f += a * noise(p); p = rot(1.6) * p * 2.0; a *= 0.5;
        } return f;
    }
    float fbm(vec3 p, int octaves) {
        float f=0.0; float a=0.5;
        for (int i=0; i<5; i++) {
             if (i >= octaves) break;
            f += a * noise(p); p.xy = rot(1.6) * p.xy; p = p.yzx * 2.0; a *= 0.5;
        } return f;
    }
    
    #if QUALITY_LEVEL == QUALITY_POTATO
    float bayer4(vec2 p) {
        const mat4 bayer = mat4(
            0.0, 8.0, 2.0, 10.0,
            12.0, 4.0, 14.0, 6.0,
            3.0, 11.0, 1.0, 9.0,
            15.0, 7.0, 13.0, 5.0
        ) / 16.0;
        
        int c = int(mod(p.x, 4.0));
        int r = int(mod(p.y, 4.0));
        
        vec4 col;
        if (c == 0) col = bayer[0];
        else if (c == 1) col = bayer[1];
        else if (c == 2) col = bayer[2];
        else col = bayer[3];

        if (r == 0) return col.x;
        else if (r == 1) return col.y;
        else if (r == 2) return col.z;
        else return col.w;
    }
    #endif

    // --- World Generation ---
    float getTerrainHeight(vec2 p) {
        vec2 p_seeded = p + u_seed;
    #if QUALITY_LEVEL == QUALITY_POTATO
        return fbm(p_seeded * 0.0008, 3) * 40.0;
    #else
        float continental_noise = fbm(p_seeded * 0.00015, 5);
        float continental_mask = smoothstep(0.4, 0.6, continental_noise);
        float base_terrain = fbm(p_seeded * 0.0008, 6) * 40.0;
        float mountain_noise = 1.0 - abs(fbm(p_seeded * 0.0015 + vec2(12.3, 45.6), 7));
        float mountains = pow(mountain_noise, 3.0) * 650.0;
        float height = base_terrain + mountains * continental_mask;

        #if QUALITY_LEVEL >= QUALITY_LOW
            float dist_to_cam = distance(p, u_camPos.xz);
            float medium_detail_strength = smoothstep(600.0, 300.0, dist_to_cam);
            if (medium_detail_strength > 0.0) {
                height += fbm(p_seeded * 0.01, 7) * 5.0 * (1.0 - continental_mask) * medium_detail_strength;
                height += fbm(p_seeded * 0.05, 6) * 1.5 * medium_detail_strength;
            }
            float fine_detail_strength = smoothstep(200.0, 80.0, dist_to_cam);
            if (fine_detail_strength > 0.0) {
                 height += fbm(p_seeded * 0.25, 6) * 0.6 * fine_detail_strength;
            }
        #endif
        return height;
    #endif
    }

    vec2 map(vec3 p) {
        float terrainHeight = getTerrainHeight(p.xz);
        float terrainDist = p.y - terrainHeight;
        #if QUALITY_LEVEL > QUALITY_POTATO
            float wave_factor = 1.0 - smoothstep(1.0, 2.0, u_weather);
            float water_waves = sin(p.x * 0.5 + u_time) * cos(p.z * 0.2 + u_time) * 0.05 * wave_factor;
            float waterDist = p.y - (SEA_LEVEL + water_waves);
            if (waterDist < terrainDist) return vec2(waterDist, MAT_WATER);
        #else
            if (p.y < SEA_LEVEL) return vec2(p.y - SEA_LEVEL, MAT_WATER);
        #endif
        return vec2(terrainDist, MAT_TERRAIN);
    }

    vec2 map_no_water(vec3 p) {
        float terrainHeight = getTerrainHeight(p.xz);
        return vec2(p.y - terrainHeight, MAT_TERRAIN);
    }
    
    // --- Rendering Functions ---
    vec3 calcNormal(vec3 p, float eps) {
        vec2 e = vec2(eps, 0.0);
        float d = map(p).x;
        return normalize(vec3(d - map(p - e.xyy).x, d - map(p - e.yxy).x, d - map(p - e.yyx).x));
    }
    
    #if QUALITY_LEVEL >= QUALITY_MEDIUM
    float calcAO(vec3 p, vec3 n) {
        float occ = 0.0, sca = 1.0;
        for(int i=0; i<AO_STEPS; i++) {
            float h = 0.01 + 0.15*float(i)/float(AO_STEPS-1);
            float d = map(p + n * h).x;
            occ += (h - d)*sca;
            sca *= 0.75;
        }
        return clamp(1.0 - 2.5*occ, 0.0, 1.0);
    }
    #else
        float calcAO(vec3 p, vec3 n) { return 1.0; }
    #endif

    #if QUALITY_LEVEL >= QUALITY_MEDIUM
    float calcSoftShadow(vec3 ro, vec3 rd, float k) {
        float res = 1.0, t = 0.05;
        for (int i = 0; i < SHADOW_STEPS; i++) {
            if (t > 80.0) break;
            float h = map(ro + rd * t).x;
            if (h < SURF_DIST) return 0.0;
            res = min(res, k * h / t);
            t += h * 0.8;
        }
        return clamp(res, 0.0, 1.0);
    }
    #elif QUALITY_LEVEL >= QUALITY_LOW
    float calcHardShadow(vec3 ro, vec3 rd) {
        float t = 0.05;
        for (int i=0; i<25; i++) {
            if (t > 80.0) break;
            float h = map(ro + rd * t).x;
            if (h < SURF_DIST) return 0.0;
            t += h;
        }
        return 1.0;
    }
    #endif

    #if QUALITY_LEVEL == QUALITY_POTATO
    vec3 getAtmosphere(vec3 rd, vec3 sunDir, out vec3 sunColor) {
        sunColor = vec3(1.0, 0.9, 0.7);
        float sunY = max(0.0, sunDir.y);
        vec3 sky = mix(vec3(0.8, 0.5, 0.9), vec3(0.1, 0.2, 0.4), smoothstep(0.0, 0.2, rd.y));
        sky = mix(sky, vec3(0.1, 0.05, 0.15), 1.0 - smoothstep(0.0, 0.1, sunY));
        sky += sunColor * pow(max(0.0, dot(rd, sunDir)), 64.0);

        if (sunDir.y < 0.01) {
            vec3 stars_uv = normalize(rd);
            float star_noise = pow(rand(stars_uv.xy * 1000.0), 40.0);
            float night_fade = 1.0 - smoothstep(0.0, 0.01, sunDir.y);
            sky += vec3(1.0) * star_noise * night_fade;
        }
        return sky;
    }
    #else
    vec3 getAtmosphere(vec3 rd, vec3 sunDir, out vec3 sunColor) {
        float sunHeight = max(0.0, sunDir.y);
        float weather_factor = smoothstep(0.0, 1.0, u_weather);
    #if QUALITY_LEVEL >= QUALITY_MEDIUM
        float rayleigh = (1.0 - pow(rd.y, 2.0));
        vec3 rayleighColor = mix(vec3(0.1, 0.22, 0.4), vec3(0.3), weather_factor) * rayleigh;
        float mie = pow(max(0.0, dot(rd, sunDir)), 32.0);
        vec3 mieColor = vec3(0.9, 0.85, 0.7) * mie;
        float horizonT = pow(1.0 - max(0.0, rd.y), 5.0);
        vec3 horizonColor = mix(vec3(0.4, 0.3, 0.2), vec3(0.9, 0.6, 0.4), pow(sunHeight, 0.5));
        vec3 skyColor = rayleighColor + mieColor * (1.0-weather_factor) + horizonColor * horizonT;
        sunColor = mix(vec3(1.0, 0.6, 0.2), vec3(1.0, 0.95, 0.9), smoothstep(0.0, 0.1, sunHeight));
        skyColor += sunColor * pow(max(0.0, dot(rd, sunDir)), 4096.0);
    #else
        vec3 topColor = mix(vec3(0.15, 0.25, 0.45), vec3(0.35), weather_factor);
        vec3 horizonColor = mix(vec3(0.7, 0.35, 0.2), vec3(0.4, 0.3, 0.25), sunHeight);
        vec3 skyColor = mix(horizonColor, topColor, smoothstep(0.0, 0.4, rd.y));
        sunColor = mix(vec3(1.0, 0.7, 0.4), vec3(1.0, 0.95, 0.9), smoothstep(0.0, 0.15, sunHeight));
        skyColor += sunColor * pow(max(0.0, dot(rd, sunDir)), 1024.0);
    #endif
        sunColor = mix(sunColor, vec3(0.8, 0.85, 0.9), weather_factor * 0.8);
        skyColor = mix(vec3(0.0), skyColor, smoothstep(-0.05, 0.05, sunDir.y));

        if (sunDir.y < 0.01) {
            vec3 stars_uv = normalize(rd);
            float star_noise = pow(rand(stars_uv.xy * 2000.0), 30.0);
            float star_noise2 = pow(rand(stars_uv.xy * 500.0), 40.0);
            float night_fade = 1.0 - smoothstep(0.0, 0.01, sunDir.y);
            skyColor += vec3(1.0) * (star_noise + star_noise2 * 0.5) * night_fade;
        }
        return skyColor;
    }
    #endif
    
    // --- Volumetric Clouds ---
    const float CLOUD_MIN_H = 300.0;
    const float CLOUD_MAX_H = 500.0;

    float cloud_map(vec3 p) {
        p.xz += u_seed; p.x += u_time * 10.0;
        float clear_density = smoothstep(0.45, 0.6, fbm(p * 0.003, 5)) * (0.5 + 0.5 * fbm(p * 0.015, 3));
        float overcast_density = smoothstep(0.4, 0.55, fbm(p * 0.002, 6)) * 0.8;
        float base_density = mix(clear_density, overcast_density, smoothstep(0.0, 1.0, u_weather));
        float height_gradient = pow(1.0 - abs(p.y - (CLOUD_MIN_H + CLOUD_MAX_H) * 0.5) / ((CLOUD_MAX_H - CLOUD_MIN_H) * 0.5), 1.5);
        return clamp(base_density * height_gradient, 0.0, 1.0);
    }
    
    #if QUALITY_LEVEL >= QUALITY_MEDIUM
    // Henyey-Greenstein scattering phase function
    float henyey_greenstein(float cos_theta, float g) {
        float g2 = g * g;
        return (1.0 - g2) / (4.0 * 3.1415926535 * pow(1.0 + g2 - 2.0 * g * cos_theta, 1.5));
    }

    void renderVolumetricClouds(vec3 ro, vec3 rd, vec3 sunDir, vec3 sunColor, inout vec3 col, inout float transmittance) {
        if (rd.y < -0.05) return;
        float t_enter = max(0.0, (CLOUD_MIN_H - ro.y) / rd.y);
        float t_exit = (CLOUD_MAX_H - ro.y) / rd.y;
        if (t_enter >= t_exit || t_enter > MAX_DIST) return;
        
        float dt = (t_exit - t_enter) / float(CLOUD_STEPS);
        vec3 light_energy = vec3(0.0);
        
        for (int i = 0; i < CLOUD_STEPS; i++) {
            float t = t_enter + float(i) * dt;
            if (t > MAX_DIST) break;
            vec3 p = ro + rd * t;
            float density = cloud_map(p);
            if (density > 0.01) {
                float phase = henyey_greenstein(dot(rd, sunDir), 0.4);
                vec3 scatter_color = sunColor * phase;
                float step_transmittance = exp(-density * dt * 2.0);
                light_energy += scatter_color * density * dt * transmittance;
                transmittance *= step_transmittance;
                if (transmittance < 0.01) break;
            }
        }
        col += light_energy;
    }
    #endif

    #if QUALITY_LEVEL >= QUALITY_HIGH
    float calcCloudShadow(vec3 p, vec3 sunDir) {
        if (sunDir.y < 0.0) return 1.0;
        float t_enter = max(0.0, (CLOUD_MIN_H - p.y) / sunDir.y);
        float t_exit = (CLOUD_MAX_H - p.y) / sunDir.y;
        if (t_enter >= t_exit) return 1.0;

        float dt = (t_exit - t_enter) / 16.0;
        float transmittance = 1.0;
        for (int i=0; i<16; i++) {
            vec3 pos = p + sunDir * (t_enter + float(i) * dt);
            transmittance *= exp(-cloud_map(pos) * dt * 2.5);
            if (transmittance < 0.01) break;
        }
        return 0.4 + 0.6 * transmittance;
    }
    #endif

    vec3 renderRain(vec3 ro, vec3 rd, float time) {
        if (u_weather < 1.5 || rd.y > -0.1) return vec3(0.0);
        float rain_amount = smoothstep(1.5, 2.0, u_weather);
        vec3 rain_color = vec3(0.0);
        for (int i=0; i<3; i++) {
            float z = float(i) * 5.0 + 2.0;
            vec3 p = ro + rd * z;
            vec2 grid_p = p.xz / 8.0;
            vec2 grid_ip = floor(grid_p);
            float h = rand(grid_ip);
            vec2 drop_pos = fract(grid_p) - vec2(0.5) + vec2(rand(grid_ip + h), rand(grid_ip - h));
            drop_pos.y += mod(time * -40.0 / z, 1.0);
            float dist = length(drop_pos);
            float streak = max(0.0, 1.0 - dist * 10.0) * pow(1.0 - abs(drop_pos.y - 0.5) * 2.0, 5.0);
            rain_color += vec3(streak) * (1.0 / z) * 0.5 * rain_amount;
        }
        return rain_color;
    }

    #if QUALITY_LEVEL == QUALITY_POTATO
    Material getMaterial(float id, vec3 p, vec3 n) {
        Material m;
        m.smoothness = 0.0;
        m.specularity = 0.0;
        if (id < 1.5) { // Terrain
            vec3 rockColor = vec3(0.35);
            vec3 grassColor = vec3(0.1, 0.5, 0.2);
            m.albedo = mix(grassColor, rockColor, pow(1.0 - clamp(n.y, 0.0, 1.0), 2.0));
            vec3 sandColor = vec3(0.9, 0.8, 0.6);
            float sandMix = smoothstep(SEA_LEVEL + 1.0, SEA_LEVEL, p.y);
            m.albedo = mix(m.albedo, sandColor, sandMix);
        }
        return m;
    }
    #else
    Material getMaterial(float id, vec3 p, vec3 n) {
        Material m; m.albedo = vec3(1.0); m.smoothness = 0.1; m.specularity = 0.1;
        if (id < 1.5) { // Terrain
            vec2 p_seeded = p.xz + u_seed;
            vec3 rockColor = vec3(0.45) * (0.9 + 0.2 * noise(p_seeded * 0.5));
            vec3 grassColor = vec3(0.2, 0.6, 0.15);
            m.albedo = mix(grassColor, rockColor, pow(1.0 - clamp(n.y, 0.0, 1.0), 1.5));
            m.albedo *= (0.8 + 0.2 * noise(p_seeded * 30.0));
            vec3 sandColor = vec3(0.85, 0.75, 0.55);
            float sandMix = (1.0 - smoothstep(SEA_LEVEL, SEA_LEVEL + 1.5, p.y)) * smoothstep(0.9, 0.8, n.y);
            m.albedo = mix(m.albedo, sandColor, sandMix);
            m.smoothness = mix(m.smoothness, 0.4, sandMix);
            if (p.y > SNOW_LINE) {
                float snowNoise = noise(p_seeded * 2.0);
                m.albedo = mix(m.albedo, vec3(0.95), smoothstep(SNOW_LINE - 10.0, SNOW_LINE + 10.0 + snowNoise*3.0, p.y));
                m.smoothness = 0.6; m.specularity = 0.8;
            }
            if (u_weather > 1.5) {
                float rain_factor = smoothstep(1.5, 2.0, u_weather);
                m.smoothness = mix(m.smoothness, 0.8, rain_factor);
                m.albedo *= mix(1.0, 0.6, rain_factor);
                m.specularity = mix(m.specularity, 0.9, rain_factor);
            }
        }
        return m;
    }
    #endif

    vec2 rayMarch(vec3 ro, vec3 rd) {
        float d = 0.0; float lastMatId = 0.0;
        for (int i = 0; i < MAX_STEPS; i++) {
            vec3 p = ro + rd * d;
            vec2 res = map(p);
            #if QUALITY_LEVEL == QUALITY_POTATO
                d += res.x * 0.8;
            #else
                d += res.x * clamp(d * 0.01, 0.6, 1.5);
            #endif
            lastMatId = res.y;
            if (abs(res.x) < SURF_DIST * max(1.0,d) || d > MAX_DIST) break;
        } return vec2(d, lastMatId);
    }

    void main() {
        vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / u_resolution.y;
        vec3 ro = u_camPos;
        vec3 rd = u_camMat * normalize(vec3(uv, 1.8));

        vec3 sunDir = normalize(u_sunDir);
        vec3 sunColor;
        vec3 skyColor = getAtmosphere(rd, sunDir, sunColor);
        vec3 col = skyColor;
        float transmittance = 1.0;

        #if QUALITY_LEVEL >= QUALITY_MEDIUM
            renderVolumetricClouds(ro, rd, sunDir, sunColor, col, transmittance);
        #endif

        vec2 hit = rayMarch(ro, rd);
        float d = hit.x;
        float materialID = hit.y;

        if (d < MAX_DIST) {
            vec3 p = ro + rd * d;
            vec3 n = calcNormal(p, SURF_DIST * max(1.0, d * 0.01));
            vec3 v = -rd;
            vec3 surfaceColor;

            if (materialID > 1.5 && materialID < 2.5) { // Water
            #if QUALITY_LEVEL >= QUALITY_LOW
                vec3 reflectedRay = reflect(rd, n);
                vec3 reflectionColor = getAtmosphere(reflectedRay, sunDir, sunColor);
                float reflTransmittance = 1.0;
                #if QUALITY_LEVEL >= QUALITY_MEDIUM
                    renderVolumetricClouds(p, reflectedRay, sunDir, sunColor, reflectionColor, reflTransmittance);
                #endif
                float depth = map_no_water(p - n*0.1).x;
                vec3 waterColor = mix(vec3(0.1, 0.2, 0.3), vec3(0.0, 0.4, 0.4), exp(-depth*0.2));
                float fresnel = pow(1.0 - max(0.0, dot(v, n)), 5.0);
                surfaceColor = mix(waterColor, reflectionColor, fresnel);
                vec3 h = normalize(sunDir + v);
                surfaceColor += sunColor * pow(max(dot(n, h), 0.0), 256.0) * 2.0;
            #else
                surfaceColor = mix(vec3(0.1, 0.2, 0.3), skyColor, pow(1.0-max(0.0, dot(v,n)), 3.0));
            #endif
            } else { // Terrain
                Material mat = getMaterial(materialID, p, n);
                float ao = calcAO(p, n);
                float shadow = 1.0;
                #if QUALITY_LEVEL >= QUALITY_MEDIUM
                    shadow = calcSoftShadow(p + n * 0.02, sunDir, 16.0);
                #elif QUALITY_LEVEL >= QUALITY_LOW
                    shadow = calcHardShadow(p + n * 0.02, sunDir);
                #endif

                #if QUALITY_LEVEL >= QUALITY_HIGH
                    shadow *= calcCloudShadow(p, sunDir);
                #endif
                
                float weather_factor = smoothstep(0.0, 1.0, u_weather);
                shadow = mix(shadow, 1.0, weather_factor * 0.7);

                vec3 h = normalize(sunDir + v);
                vec3 lighting = mat.albedo * (skyColor * (0.5 + 0.5 * n.y) * ao + sunColor * max(dot(n, sunDir), 0.0) * shadow);
                lighting += sunColor * pow(max(dot(n, h), 0.0), 1.0/max(0.01, (1.0 - mat.smoothness))) * shadow * mat.specularity * ao;
                surfaceColor = lighting;
            }
            
            float fogAmount = exp(-d * (0.0002 + exp(-ro.y * 0.005) * 0.002));
            vec3 foggedSurface = mix(skyColor, surfaceColor, fogAmount);
            col = mix(foggedSurface, col, 1.0 - transmittance);
            col += renderRain(ro, rd, u_time);
        }
        
        #if QUALITY_LEVEL == QUALITY_POTATO
            // Posterize
            col = floor(col * 6.0) / 6.0;
            // Dithering
            col += (bayer4(gl_FragCoord.xy) - 0.5) / 16.0;
            // Simple vignette
            col *= 1.0 - dot(uv, uv) * 0.35;
        #else
            col *= 1.0 - dot(uv, uv) * 0.25;
            col = pow(col, vec3(0.8));
        #endif

        gl_FragColor = vec4(col, 1.0);
    }
    </script>

    <!-- Main Application Logic -->
    <script type="module">
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl', { antialias: false, powerPreference: 'high-performance' }) 
                   || canvas.getContext('experimental-webgl');

        if (!gl) {
            alert('Your browser does not support WebGL.');
            throw new Error('WebGL not supported');
        }
        
        let isMobile = false;
        let worldSeed = Math.random() * 1000.0;
        let timeOfDay = 0.25; 
        let weatherState = 0.0;

        const camera = { 
            pos: [0, 50, -5], yaw: Math.PI, pitch: -0.2,
            velocity: [0, 0, 0], angularVelocity: { yaw: 0, pitch: 0 }
        };
        const input = { keys: new Set(), moveVec: { x: 0, y: 0 } };
        
        const MOUSE_SENSITIVITY = 0.002;
        const TOUCH_SENSITIVITY = 0.003;
        const ACCELERATION = 120.0;
        const DAMPING = 15.0;
        const ANGULAR_DAMPING = 10.0;

        const audioManager = {
            context: null,
            masterGain: null,
            sounds: {
                wind: { url: 'https://cdn.pixabay.com/download/audio/2022/10/20/audio_1c5b16260a.mp3', gainValue: 0.3 },
                rain: { url: 'https://cdn.pixabay.com/download/audio/2023/08/04/audio_354b099a22.mp3', gainValue: 0.8 },
                day: { url: 'https://cdn.pixabay.com/download/audio/2022/06/14/audio_34b7f339f4.mp3', gainValue: 0.5 },
                night: { url: 'https://cdn.pixabay.com/download/audio/2021/08/04/audio_51a965d194.mp3', gainValue: 0.5 },
                waves: { url: 'https://cdn.pixabay.com/download/audio/2024/02/09/audio_6a8e874136.mp3', gainValue: 0.7 },
            },
            isInitialized: false,
            
            async init() {
                if (this.isInitialized || this.context) return;
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.context.createGain();
                    this.masterGain.gain.value = 0.5; // Default volume from slider
                    this.masterGain.connect(this.context.destination);

                    for (const key in this.sounds) {
                        const sound = this.sounds[key];
                        const response = await fetch(sound.url);
                        const arrayBuffer = await response.arrayBuffer();
                        sound.buffer = await this.context.decodeAudioData(arrayBuffer);

                        sound.gain = this.context.createGain();
                        sound.gain.gain.value = 0.0; // Start silent
                        sound.gain.connect(this.masterGain);

                        sound.source = this.context.createBufferSource();
                        sound.source.buffer = sound.buffer;
                        sound.source.loop = true;
                        sound.source.connect(sound.gain);
                        sound.source.start(0);
                    }
                    this.isInitialized = true;
                } catch (e) {
                    console.error("Error initializing audio:", e);
                }
            },

            update(timeOfDay, weatherState, camPos) {
                if (!this.isInitialized) return;
                const now = this.context.currentTime;
                const fadeTime = now + 1.0; // 1 second fade

                const sunAngle = (timeOfDay - 0.25) * 2.0 * Math.PI;
                const sunY = Math.cos(sunAngle);

                const dayAmount = this._smoothstep(0.0, 0.1, sunY);
                const nightAmount = this._smoothstep(0.0, -0.1, -sunY);
                const clearAmount = 1.0 - this._smoothstep(0.0, 1.0, weatherState);
                const rainAmount = this._smoothstep(1.5, 2.0, weatherState);

                this.sounds.day.gain.gain.linearRampToValueAtTime(dayAmount * this.sounds.day.gainValue * clearAmount, fadeTime);
                this.sounds.night.gain.gain.linearRampToValueAtTime(nightAmount * this.sounds.night.gainValue, fadeTime);
                this.sounds.rain.gain.gain.linearRampToValueAtTime(rainAmount * this.sounds.rain.gainValue, fadeTime);
                this.sounds.wind.gain.gain.linearRampToValueAtTime(this.sounds.wind.gainValue * (0.5 + rainAmount * 0.5), fadeTime);

                const distToSea = Math.abs(camPos[1] - SEA_LEVEL);
                const waveAmount = this._smoothstep(60.0, 5.0, distToSea);
                this.sounds.waves.gain.gain.linearRampToValueAtTime(waveAmount * this.sounds.waves.gainValue, fadeTime);
            },
            
            setMasterVolume(volume) {
                if (!this.isInitialized) return;
                this.masterGain.gain.linearRampToValueAtTime(volume, this.context.currentTime + 0.1);
            },

            _smoothstep: (edge0, edge1, x) => {
                const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
                return t * t * (3 - 2 * t);
            }
        };

        const perf = {
            frameTimes: [],
            avgFps: 60,
            currentQuality: '',
            resolutionScale: 1.0,
            isSwitching: false,
            
            update: function(deltaTime) {
                this.frameTimes.push(1.0 / deltaTime);
                if (this.frameTimes.length > 60) this.frameTimes.shift();
                if (this.frameTimes.length < 30 || this.isSwitching) return;

                this.avgFps = this.frameTimes.reduce((a, b) => a + b) / this.frameTimes.length;

                const q = this.currentQuality;
                if (this.avgFps < 35) {
                    if (q === 'ULTRA') this.setQuality('HIGH');
                    else if (q === 'HIGH') this.setQuality('MEDIUM');
                    else if (q === 'MEDIUM') this.setQuality('LOW');
                    else if (q === 'LOW') this.setQuality('POTATO');
                } else if (this.avgFps > 58) {
                    if (q === 'POTATO') this.setQuality('LOW');
                    else if (q === 'LOW') this.setQuality('MEDIUM');
                    else if (q === 'MEDIUM') this.setQuality('HIGH');
                }
            },
            setQuality: async function(level) {
                if (this.currentQuality === level || this.isSwitching) return;
                console.log(`Adapting quality to: ${level}`);
                this.isSwitching = true;
                this.currentQuality = level;
                
                if (level === 'ULTRA') this.resolutionScale = 1.0;
                else if (level === 'HIGH') this.resolutionScale = 0.9;
                else if (level === 'MEDIUM') this.resolutionScale = 0.75;
                else if (level === 'LOW') this.resolutionScale = 0.6;
                else this.resolutionScale = 0.5;
                
                await rebuildShaderProgram(level);
                this.frameTimes = [];
                this.isSwitching = false;
            }
        };
        
        let programInfo;
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, document.getElementById('vertex-shader').text);
        const fragmentShaderSource = document.getElementById('fragment-shader').text;
        const fullScreenQuadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, fullScreenQuadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source); gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader); return null;
            }
            return shader;
        }

        async function rebuildShaderProgram(quality) {
            return new Promise((resolve) => {
                if (programInfo && programInfo.program) {
                    gl.deleteProgram(programInfo.program);
                }
                const qualityLevels = {'POTATO': 0, 'LOW': 1, 'MEDIUM': 2, 'HIGH': 3, 'ULTRA': 4};
                const fragSource = `#define QUALITY_LEVEL ${qualityLevels[quality]}\n${fragmentShaderSource}`;
                
                const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragSource);
                if (!fragmentShader) {
                    console.error("Fragment shader failed to compile. Aborting program rebuild.");
                    resolve();
                    return;
                }

                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Shader program linking error: ' + gl.getProgramInfoLog(program));
                }
                gl.deleteShader(fragmentShader);

                programInfo = {
                    program,
                    attribs: { position: gl.getAttribLocation(program, 'a_position') },
                    uniforms: {
                        resolution: gl.getUniformLocation(program, 'u_resolution'),
                        time: gl.getUniformLocation(program, 'u_time'),
                        camPos: gl.getUniformLocation(program, 'u_camPos'),
                        camMat: gl.getUniformLocation(program, 'u_camMat'),
                        sunDir: gl.getUniformLocation(program, 'u_sunDir'),
                        seed: gl.getUniformLocation(program, 'u_seed'),
                        weather: gl.getUniformLocation(program, 'u_weather'),
                    },
                };
                resolve();
            });
        }
        
        const startPrompt = document.getElementById('start-prompt');
        const debugInfo = document.getElementById('debug-info');
        let appRunning = false;
        function startApp() {
            if (appRunning) return;
            appRunning = true;
            audioManager.init();
            if (!isMobile && document.pointerLockElement !== canvas) {
                canvas.requestPointerLock();
            }
            if (!startPrompt.classList.contains('hidden')) {
                startPrompt.classList.add('hidden');
            }
        }
        canvas.addEventListener('click', startApp);
        startPrompt.addEventListener('click', startApp);
        canvas.addEventListener('touchstart', startApp, {passive: true});
        startPrompt.addEventListener('touchstart', startApp, {passive: true});
        
        function handleEscapeKey() {
            const vambaPanel = document.getElementById('vamba-panel');
            if (document.body.classList.contains('photo-mode')) {
                document.body.classList.remove('photo-mode');
            } else if (document.pointerLockElement === canvas) {
                document.exitPointerLock();
            } else if (!isMobile) {
                const isVisible = vambaPanel.style.transform !== 'translateX(-100%)';
                vambaPanel.style.transform = isVisible ? 'translateX(-100%)' : 'translateX(0)';
            } else if (isMobile && vambaPanel.classList.contains('mobile-visible')) {
                vambaPanel.classList.remove('mobile-visible');
            }
        }

        window.addEventListener('keydown', (e) => { e.code === 'Escape' ? handleEscapeKey() : input.keys.add(e.code); });
        window.addEventListener('keyup', (e) => input.keys.delete(e.code));

        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === canvas) {
                document.addEventListener('mousemove', updateMouse, false);
            } else {
                document.removeEventListener('mousemove', updateMouse, false);
            }
        });
        function updateMouse(e) {
            camera.angularVelocity.yaw -= e.movementX * MOUSE_SENSITIVITY;
            camera.angularVelocity.pitch -= e.movementY * MOUSE_SENSITIVITY;
        }

        function initMobileControls() {
            document.getElementById('mobile-controls').style.display = 'block';
            
            const joyHandle = document.getElementById('joystick-handle');
            const maxJoyDist = document.getElementById('joystick-container').clientWidth / 2;
            const joyState = { touchId: -1, startX: 0, startY: 0 };
            const lookState = { touchId: -1, prevX: 0, prevY: 0 };

            function handleButton(key, start) { return (e) => { e.preventDefault(); if(start) input.keys.add(key); else input.keys.delete(key); } }
            document.getElementById('sprint-button').addEventListener('touchstart', handleButton('MobileSprint', true), {passive: false});
            document.getElementById('sprint-button').addEventListener('touchend', handleButton('MobileSprint', false), {passive: false});
            document.getElementById('up-button').addEventListener('touchstart', handleButton('MobileUp', true), {passive: false});
            document.getElementById('up-button').addEventListener('touchend', handleButton('MobileUp', false), {passive: false});
            document.getElementById('down-button').addEventListener('touchstart', handleButton('MobileDown', true), {passive: false});
            document.getElementById('down-button').addEventListener('touchend', handleButton('MobileDown', false), {passive: false});

            canvas.addEventListener('touchstart', (e) => {
                 for (const touch of e.changedTouches) {
                    if (touch.clientX > window.innerWidth / 2) {
                        if (lookState.touchId === -1) { Object.assign(lookState, {touchId: touch.identifier, prevX: touch.clientX, prevY: touch.clientY}); }
                    } else {
                         if (joyState.touchId === -1) { Object.assign(joyState, {touchId: touch.identifier, startX: touch.clientX, startY: touch.clientY}); }
                    }
                 }
            }, {passive: true});
            
            canvas.addEventListener('touchmove', (e) => {
                 e.preventDefault();
                 for (const touch of e.changedTouches) {
                    if (touch.identifier === lookState.touchId) {
                        camera.angularVelocity.yaw -= (touch.clientX - lookState.prevX) * TOUCH_SENSITIVITY;
                        camera.angularVelocity.pitch -= (touch.clientY - lookState.prevY) * TOUCH_SENSITIVITY;
                        lookState.prevX = touch.clientX; lookState.prevY = touch.clientY;
                    } else if (touch.identifier === joyState.touchId) {
                        const dx = touch.clientX - joyState.startX, dy = touch.clientY - joyState.startY;
                        const clampedDist = Math.min(Math.sqrt(dx*dx + dy*dy), maxJoyDist);
                        const angle = Math.atan2(dy, dx);
                        joyHandle.style.transform = `translate(-50%, -50%) translate(${Math.cos(angle) * clampedDist}px, ${Math.sin(angle) * clampedDist}px)`;
                        input.moveVec.x = Math.cos(angle) * clampedDist / maxJoyDist;
                        input.moveVec.y = - (Math.sin(angle) * clampedDist / maxJoyDist);
                    }
                 }
            }, {passive: false});

            canvas.addEventListener('touchend', (e) => {
                for (const touch of e.changedTouches) {
                    if (touch.identifier === lookState.touchId) lookState.touchId = -1;
                    else if (touch.identifier === joyState.touchId) {
                        joyState.touchId = -1;
                        input.moveVec.x = 0; input.moveVec.y = 0;
                        joyHandle.style.transform = `translate(-50%, -50%)`;
                    }
                }
            });
        }

        function updateCamera(deltaTime) {
            camera.yaw += camera.angularVelocity.yaw;
            camera.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.pitch + camera.angularVelocity.pitch));
            camera.angularVelocity.yaw *= Math.exp(-ANGULAR_DAMPING * deltaTime);
            camera.angularVelocity.pitch *= Math.exp(-ANGULAR_DAMPING * deltaTime);
            
            const boost = input.keys.has('ShiftLeft') || input.keys.has('ShiftRight') || input.keys.has('MobileSprint');
            const currentAcceleration = ACCELERATION * (boost ? 5.0 : 1.0);
            
            let f = (input.keys.has('KeyW')||input.keys.has('ArrowUp')?1:0)-(input.keys.has('KeyS')||input.keys.has('ArrowDown')?1:0) - input.moveVec.y;
            let r = (input.keys.has('KeyD')||input.keys.has('ArrowRight')?1:0)-(input.keys.has('KeyA')||input.keys.has('ArrowLeft')?1:0) + input.moveVec.x;
            let u = (input.keys.has('Space') || input.keys.has('MobileUp') ? 1:0) - (input.keys.has('KeyQ') || input.keys.has('MobileDown') ?1:0);
            
            const len = Math.sqrt(f*f + r*r);
            if (len > 0.001) { f /= len; r /= len; }

            let moveX = (f * Math.sin(camera.yaw)) + (r * Math.cos(camera.yaw));
            let moveZ = (f * Math.cos(camera.yaw)) - (r * Math.sin(camera.yaw));

            const targetVel = [moveX * currentAcceleration, u * currentAcceleration, moveZ * currentAcceleration];
            for(let i=0; i<3; ++i) {
                camera.velocity[i] += (targetVel[i] - camera.velocity[i]) * (targetVel[i] === 0 ? DAMPING : 1.0) * deltaTime;
                camera.pos[i] += camera.velocity[i] * deltaTime;
            }
        }

        function initVambaPanel() {
            const tabs = document.querySelectorAll('.tab-link');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.tab).classList.add('active');
                });
            });

            const usefulLinks = [ /* Links data */ ];
            // ... (link logic is unchanged, can be condensed)
            
            document.getElementById('regenerate-world-btn').addEventListener('click', () => { worldSeed = Math.random() * 1000.0; });
            document.getElementById('time-slider').addEventListener('input', (e) => { timeOfDay = parseFloat(e.target.value); });
            document.getElementById('weather-controls').addEventListener('click', (e) => {
                if (e.target.classList.contains('weather-btn')) {
                    weatherState = parseFloat(e.target.dataset.weather);
                    document.querySelectorAll('.weather-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                }
            });
            document.getElementById('volume-slider').addEventListener('input', (e) => {
                audioManager.setMasterVolume(parseFloat(e.target.value));
            });
            document.getElementById('photo-mode-btn').addEventListener('click', () => { document.body.classList.toggle('photo-mode'); });
            document.getElementById('mobile-menu-toggle').addEventListener('click', () => { document.getElementById('vamba-panel').classList.toggle('mobile-visible'); });
        }
        
        let lastTime = 0;
        function render(time) {
            time *= 0.001;
            const deltaTime = Math.min(0.1, time - lastTime);
            lastTime = time;

            if (appRunning && deltaTime > 0) {
                 updateCamera(deltaTime);
                 audioManager.update(timeOfDay, weatherState, camera.pos);
                 perf.update(deltaTime);
            }

            const dpr = window.devicePixelRatio || 1;
            const displayWidth = Math.round(canvas.clientWidth * dpr * perf.resolutionScale);
            const displayHeight = Math.round(canvas.clientHeight * dpr * perf.resolutionScale);
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth; canvas.height = displayHeight;
            }

            if (!programInfo) { requestAnimationFrame(render); return; }

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.useProgram(programInfo.program);
            gl.bindBuffer(gl.ARRAY_BUFFER, fullScreenQuadBuffer);
            gl.vertexAttribPointer(programInfo.attribs.position, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo.attribs.position);

            const cy = Math.cos(camera.yaw), sy = Math.sin(camera.yaw);
            const cp = Math.cos(camera.pitch), sp = Math.sin(camera.pitch);
            const camMat = [cy, 0, -sy, sp*sy, cp, sp*cy, cp*sy, -sp, cp*cy];
            const sunAngle = (timeOfDay - 0.25) * 2.0 * Math.PI;
            const sunDir = [Math.sin(sunAngle), Math.cos(sunAngle), -0.2];

            gl.uniform2f(programInfo.uniforms.resolution, canvas.width, canvas.height);
            gl.uniform1f(programInfo.uniforms.time, time);
            gl.uniform3fv(programInfo.uniforms.camPos, camera.pos);
            gl.uniformMatrix3fv(programInfo.uniforms.camMat, false, camMat);
            gl.uniform3fv(programInfo.uniforms.sunDir, sunDir);
            gl.uniform1f(programInfo.uniforms.seed, worldSeed);
            gl.uniform1f(programInfo.uniforms.weather, weatherState);
            
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            debugInfo.textContent = `FPS: ${Math.round(perf.avgFps)} | Q: ${perf.currentQuality} | Pos: ${camera.pos.map(c=>c.toFixed(0)).join(', ')}`;
            requestAnimationFrame(render);
        }
        
        async function main() {
            isMobile = /Mobi|Android/i.test(navigator.userAgent);
            if (isMobile) {
                initMobileControls();
            }
            initVambaPanel(); // Init for both mobile and desktop

            await perf.setQuality(isMobile ? 'MEDIUM' : 'HIGH');
            requestAnimationFrame(render);
        }

        main();
    </script>
</body>
</html>
