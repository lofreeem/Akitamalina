<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Wave P2P Chat</title>
<style>
body { font-family: monospace; background:#111; color:#0f0; display:flex; flex-direction:column; align-items:center; padding:20px;}
#messages { width:400px; height:200px; overflow-y:auto; border:1px solid #0f0; padding:5px; margin-bottom:10px;}
input { width:400px; margin-bottom:10px; }
button { margin:2px; }
</style>
</head>
<body>
<h2>Авто P2P Chat</h2>
<div id="messages"></div>
<input id="input" placeholder="Введите сообщение и Enter">
<button onclick="start()">Начать комнату</button>

<script>
const messages = document.getElementById("messages");
const input = document.getElementById("input");

let peers = {};        // {peerId: RTCPeerConnection}
let channels = {};     // {peerId: DataChannel}
let uid = Math.random().toString(36).substr(2,6);

// Псевдо-публичное хранилище через localStorage (для примера)
let roomKey = 'waveRoom';
let signals = JSON.parse(localStorage.getItem(roomKey)||'{}');

function log(msg){
  const d=document.createElement("div"); d.textContent=msg; messages.appendChild(d);
  messages.scrollTop = messages.scrollHeight;
}

// ===== Инициализация комнаты =====
function start(){
  log("Комната запущена. Ждите новых игроков...");
  window.addEventListener("storage", receiveSignal); // слушаем новые сигналы
  broadcastSignal({type:'hello', from:uid});
}

// ===== WebRTC peer connection =====
function createPeer(remoteId, offer){
  const pc = new RTCPeerConnection();
  peers[remoteId]=pc;

  const channel = pc.createDataChannel("wave");
  setupChannel(remoteId, channel);

  pc.onicecandidate = e=>{
    if(e.candidate) broadcastSignal({type:'ice', from:uid, to:remoteId, ice:e.candidate});
  };

  if(offer){
    pc.setRemoteDescription(new RTCSessionDescription(offer)).then(()=>{
      pc.createAnswer().then(answer=>{
        pc.setLocalDescription(answer);
        broadcastSignal({type:'answer', from:uid, to:remoteId, answer});
      });
    });
  } else {
    pc.createOffer().then(o=>{
      pc.setLocalDescription(o);
      broadcastSignal({type:'offer', from:uid, to:remoteId, offer:o});
    });
  }
}

// ===== Настройка канала =====
function setupChannel(pid, channel){
  channels[pid]=channel;
  channel.onopen = ()=>log("Канал открыт с "+pid);
  channel.onmessage = e=>log(pid+": "+e.data);
}

// ===== Отправка сообщений =====
input.addEventListener("keydown", e=>{
  if(e.key==="Enter" && input.value.trim()!==""){
    const msg=input.value.trim();
    Object.values(channels).forEach(ch=>{
      if(ch.readyState==="open") ch.send(msg);
    });
    log("Me: "+msg);
    input.value="";
  }
});

// ===== «Волновая» отправка сигналов через localStorage =====
function broadcastSignal(obj){
  signals[Date.now()+'_'+Math.random()]=obj;
  localStorage.setItem(roomKey, JSON.stringify(signals));
  // сами же обработаем сразу
  receiveSignal({newValue: JSON.stringify(signals)});
}

// ===== Обработка сигналов =====
function receiveSignal(e){
  if(!e.newValue) return;
  const allSignals = JSON.parse(e.newValue);
  Object.values(allSignals).forEach(signal=>{
    if(signal.from===uid) return; // игнорируем свои
    if(signal.to && signal.to!==uid) return; // не для нас
    if(signal.type==='hello'){
      if(!peers[signal.from]) createPeer(signal.from);
    } else if(signal.type==='offer'){
      if(!peers[signal.from]) createPeer(signal.from, signal.offer);
    } else if(signal.type==='answer'){
      peers[signal.from].setRemoteDescription(new RTCSessionDescription(signal.answer));
    } else if(signal.type==='ice'){
      peers[signal.from].addIceCandidate(new RTCIceCandidate(signal.ice));
    }
  });
}

</script>
</body>
</html>
